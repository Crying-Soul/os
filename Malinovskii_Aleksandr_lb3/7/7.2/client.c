/******************************************************************************
 * 
 *  Цель:
 *      Продемонстрировать создание простого UDP клиента, который отправляет
 *      сообщение серверу и получает ответ.
 *
 *  Описание:
 *      Программа создает сокет, отправляет сообщение на сервер по указанному
 *      IP-адресу и порту, затем принимает ответ и выводит его на экран.  В
 *      отличие от TCP, UDP - это протокол без установления соединения.
 *
 *  Основные компоненты:
 *      - `socket()`:  Создает сокет.
 *      - `sendto()`: Отправляет данные на сервер.
 *      - `recvfrom()`: Читает данные с сервера.
 *      - `close()`: Закрывает сокет.
 *      - `struct sockaddr_in`: Структура, содержащая информацию об адресе
 *        сервера (семейство протоколов, IP-адрес, порт).
 *      - `inet_pton()`: Преобразует IP-адрес из текстового представления в
 *        двоичное.
 *      - `INADDR_ANY`:  Специальный адрес, указывающий, что сокет должен
 *         быть привязан ко всем доступным локальным интерфейсам.
 *      - `MSG_CONFIRM`:  Флаг для `sendto()`, указывающий, что сообщение
 *         требует подтверждения (не реализовано в UDP, поэтому игнорируется).
 *      - `MSG_WAITALL`:  Флаг для `recvfrom()`, требующий, чтобы функция
 *         ждала, пока не получит все запрошенные байты, если это возможно.
 *
 *  Схема работы:
 *      1. Создается сокет с использованием `socket()`.
 *      2. Заполняется структура `sockaddr_in` информацией об адресе сервера.
 *      3. Отправляется сообщение на сервер с использованием `sendto()`.
 *      4. Принимается ответ от сервера с использованием `recvfrom()`.
 *      5. Выводится полученный ответ на экран.
 *      6. Закрывается сокет с использованием `close()`.
 *
 *  Примечания:
 *      - Программа предполагает, что сервер уже запущен и прослушивает
 *        указанный порт.
 *      - IP-адрес сервера жестко закодирован как "127.0.0.1" (localhost) в
 *        родительской программе.
 *      - Порт сервера задан константой PORT (12345).
 *      - Размер буфера для приема данных ограничен BUFFER_SIZE (1024 байта).
 *      - В программе не предусмотрена обработка ошибок при разрыве соединения
 *        или других сетевых проблемах.
 *      - Для компиляции необходимы заголовочные файлы `sys/socket.h`,
 *        `netinet/in.h` и `arpa/inet.h`.
 *      - Поскольку UDP не гарантирует доставку сообщений, ответ от сервера
 *        может быть не получен.
 *
 ******************************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define PORT 12345
#define BUFFER_SIZE 1024

int main() {
    int sockfd;
    struct sockaddr_in serv_addr;
    char buffer[BUFFER_SIZE];
    
    // Создание UDP сокета
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }
    
    memset(&serv_addr, 0, sizeof(serv_addr));
    
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(PORT);
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    
    // Отправка сообщения серверу
    char *message = "Привет, сервер! (UDP)";
    sendto(sockfd, message, strlen(message), 
           MSG_CONFIRM, (const struct sockaddr *)&serv_addr,
           sizeof(serv_addr));
    printf("Сообщение отправлено серверу\n");
    
    // Получение ответа от сервера
    int n = recvfrom(sockfd, (char *)buffer, BUFFER_SIZE, 
                     MSG_WAITALL, NULL, NULL);
    buffer[n] = '\0';
    printf("Ответ сервера: %s\n", buffer);
    
    close(sockfd);
    return 0;
}