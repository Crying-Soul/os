/******************************************************************************
 * 
 *  Цель:
 *      Продемонстрировать создание простого UDP сервера, который принимает
 *      сообщения от клиентов и отправляет ответы.
 *
 *  Описание:
 *      Программа создает сокет, привязывает его к указанному порту, начинает
 *      ожидать входящие UDP-дейтаграммы.  При получении данных от клиента,
 *      сервер выводит информацию об отправителе (IP-адрес и порт) и содержимое
 *      сообщения на экран, а затем отправляет ответ обратно клиенту. В
 *      отличие от TCP, UDP - это протокол без установления соединения.
 *
 *  Основные компоненты:
 *      - `socket()`:  Создает сокет.
 *      - `bind()`: Привязывает сокет к определенному IP-адресу и порту.
 *      - `recvfrom()`: Читает данные от клиента.
 *      - `sendto()`: Отправляет данные клиенту.
 *      - `close()`: Закрывает сокет.
 *      - `struct sockaddr_in`: Структура, содержащая информацию об адресе
 *        сервера и клиента (семейство протоколов, IP-адрес, порт).
 *      - `inet_ntoa()`: Преобразует IP-адрес из двоичного представления в
 *        текстовое.
 *      - `ntohs()`: Преобразует порт из сетевого байтового порядка в порядок
 *        байтов хоста.
 *      - `INADDR_ANY`:  Специальный адрес, указывающий, что сокет должен
 *         быть привязан ко всем доступным локальным интерфейсам.
 *      - `MSG_WAITALL`:  Флаг для `recvfrom()`, требующий, чтобы функция
 *         ждала, пока не получит все запрошенные байты, если это возможно.
 *      - `MSG_CONFIRM`:  Флаг для `sendto()`, указывающий, что сообщение
 *         требует подтверждения (не реализовано в UDP, поэтому игнорируется).
 *
 *  Схема работы:
 *      1. Создается сокет с использованием `socket()`.
 *      2. Заполняется структура `sockaddr_in` информацией об адресе сервера.
 *      3. Сокет привязывается к адресу с использованием `bind()`.
 *      4. Сервер начинает ожидать входящие дейтаграммы с использованием
 *         `recvfrom()`.
 *      5. После получения данных, выводится информация об отправителе и
 *         содержимое сообщения на экран.
 *      6. Отправляется ответ клиенту с использованием `sendto()`.
 *      7. Сервер возвращается к ожиданию новых сообщений.
 *
 *  Примечания:
 *      - Сервер работает в бесконечном цикле, обрабатывая входящие сообщения.
 *      - Порт сервера задан константой PORT (12345).
 *      - Адрес сервера (INADDR_ANY) означает, что сервер будет принимать
 *        соединения на всех доступных IP-адресах.
 *      - Размер буфера для приема данных ограничен BUFFER_SIZE (1024 байта).
 *      - В программе не предусмотрена обработка ошибок при разрыве соединения
 *        или других сетевых проблемах.
 *      - Для компиляции необходимы заголовочные файлы `sys/socket.h`,
 *        `netinet/in.h` и `arpa/inet.h`.
 *      - Поскольку UDP не гарантирует доставку сообщений, клиент может не
 *        получить ответ.
 *
 ******************************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define PORT 12345
#define BUFFER_SIZE 1024

int main() {
    int server_fd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_len = sizeof(client_addr);
    char buffer[BUFFER_SIZE];
    
    // Создание UDP сокета
    if ((server_fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }
    
    memset(&server_addr, 0, sizeof(server_addr));
    memset(&client_addr, 0, sizeof(client_addr));
    
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);
    
    // Привязка сокета к адресу
    if (bind(server_fd, (const struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }
    
    printf("UDP сервер слушает на порту %d...\n", PORT);
    
    while (1) {
        // Получение данных от клиента
        int n = recvfrom(server_fd, (char *)buffer, BUFFER_SIZE, 
                         MSG_WAITALL, (struct sockaddr *)&client_addr,
                         &client_len);
        buffer[n] = '\0';
        
        printf("Получено от %s:%d: %s\n", 
               inet_ntoa(client_addr.sin_addr), 
               ntohs(client_addr.sin_port), buffer);
        
        // Отправка ответа клиенту
        char *response = "Сообщение получено сервером (UDP)";
        sendto(server_fd, response, strlen(response), 
               MSG_CONFIRM, (const struct sockaddr *)&client_addr,
               client_len);
    }
    
    close(server_fd);
    return 0;
}