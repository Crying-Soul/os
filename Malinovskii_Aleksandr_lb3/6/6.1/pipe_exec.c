/******************************************************************************
 * 
 *  Цель:
 *      Продемонстрировать перенаправление стандартного ввода (stdin) дочернего
 *      процесса на чтение из анонимного канала (pipe). Родительский процесс
 *      записывает данные в канал, которые затем используются в качестве ввода
 *      для команды, выполняемой в дочернем процессе.
 *
 *  Описание:
 *      Программа создает анонимный канал (pipefd). Родительский процесс
 *      записывает несколько строк в канал, а дочерний процесс перенаправляет
 *      свой стандартный ввод на чтение из этого канала, и затем запускает
 *      команду `wc -l`, которая считает количество строк во входном потоке.
 *
 *  Основные компоненты:
 *      - `pipefd[2]`: Анонимный канал для передачи данных от родительского
 *        процесса к дочернему.
 *      - `fork()`: Создает дочерний процесс.
 *      - `dup2()`: Перенаправляет стандартный ввод дочернего процесса на
 *        чтение из канала.
 *      - `execlp()`: Запускает команду `wc -l` в дочернем процессе.
 *      - `write()`: Записывает данные в канал.
 *      - `close()`: Закрывает неиспользуемые концы каналов.
 *
 *  Схема работы:
 *      1. Родительский процесс создает канал (pipefd).
 *      2. Родительский процесс создает дочерний процесс с помощью `fork()`.
 *      3. В родительском процессе:
 *         - Закрывается конец канала для чтения.
 *         - Записываются строки в канал.
 *         - Закрывается конец канала для записи.
 *         - Ожидается завершение дочернего процесса.
 *      4. В дочернем процессе:
 *         - Закрывается конец канала для записи.
 *         - Стандартный ввод (stdin) перенаправляется на чтение из канала с
 *           помощью `dup2()`.
 *         - Закрывается исходный дескриптор канала для чтения.
 *         - Запускается команда `wc -l`, которая читает из stdin (теперь из
 *           канала).
 *
 *  Примечания:
 *      - Эта программа демонстрирует, как можно использовать каналы для
 *        передачи данных между процессами и перенаправлять ввод/вывод.
 *      - Важно закрывать неиспользуемые дескрипторы файлов.
 *      - Команда `wc -l` должна быть доступна в системе.
 *
 ******************************************************************************/


#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>
int main() {
    int pipefd[2];
    pid_t pid;
    
    if (pipe(pipefd)) {
        perror("pipe");
        return 1;
    }
    
    pid = fork();
    if (pid == 0) { // Дочерний процесс
        close(pipefd[1]); // Закрываем запись
        
        // Перенаправляем stdin на чтение из pipe
        dup2(pipefd[0], STDIN_FILENO);
        close(pipefd[0]);
        
        // Запускаем команду, которая читает из stdin
        execlp("wc", "wc", "-l", NULL);
        perror("execlp");
        return 1;
    } else { // Родительский процесс
        close(pipefd[0]); // Закрываем чтение
        
        // Пишем в pipe строки, которые будет считать wc
        const char* lines[] = {"Первая строка\n", "Вторая строка\n", "Третья строка\n"};
        for (int i = 0; i < 3; i++) {
            write(pipefd[1], lines[i], strlen(lines[i]));
        }
        
        close(pipefd[1]);
        wait(NULL); // Ждем завершения дочернего процесса
    }
    
    return 0;
}
