/******************************************************************************
 * 
 *  Цель:
 *      Продемонстрировать базовый обмен данными между родительским и
 *      дочерним процессами с использованием анонимного канала (pipe).
 *
 *  Описание:
 *      Программа создает анонимный канал (pipefd). Родительский процесс
 *      отправляет сообщение дочернему процессу через этот канал. Дочерний
 *      процесс принимает сообщение из канала и выводит его на экран.
 *
 *  Основные компоненты:
 *      - `pipefd[2]`: Анонимный канал для передачи данных от родительского
 *        процесса к дочернему.
 *      - `fork()`: Создает дочерний процесс.
 *      - `read()`: Читает данные из канала.
 *      - `write()`: Записывает данные в канал.
 *      - `close()`: Закрывает неиспользуемые концы каналов.
 *
 *  Схема работы:
 *      1. Родительский процесс создает канал (pipefd).
 *      2. Родительский процесс создает дочерний процесс с помощью `fork()`.
 *      3. В родительском процессе:
 *         - Закрывается конец канала для чтения.
 *         - Отправляется сообщение дочернему процессу через канал.
 *         - Закрывается конец канала для записи.
 *         - Ожидается завершение дочернего процесса.
 *      4. В дочернем процессе:
 *         - Закрывается конец канала для записи.
 *         - Считывается сообщение от родительского процесса из канала.
 *         - Выводится полученное сообщение на экран.
 *         - Закрывается конец канала для чтения.
 *
 *  Примечания:
 *      - Анонимные каналы используются для однонаправленной связи между
 *        процессами, имеющими общего предка.
 *      - Для обмена данными в обоих направлениях требуется два канала.
 *      - Важно закрывать неиспользуемые концы канала.
 *
 ******************************************************************************/


#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>

int main() {
    int pipefd[2];
    pid_t pid;
    char buf[256];
    
    // Создаем pipe
    if (pipe(pipefd)) {
        perror("pipe");
        return 1;
    }
    
    pid = fork();
    if (pid == 0) { // Дочерний процесс
        close(pipefd[1]); // Закрываем запись
        
        // Читаем из pipe
        read(pipefd[0], buf, sizeof(buf));
        printf("Дочерний процесс (PID=%d) получил: '%s'\n", getpid(), buf);
        
        close(pipefd[0]);
    } else { // Родительский процесс
        close(pipefd[0]); // Закрываем чтение
        
        // Пишем в pipe
        const char* msg = "Привет из родительского процесса!";
        printf("Родительский процесс (PID=%d) отправляет: '%s'\n", getpid(), msg);
        write(pipefd[1], msg, strlen(msg) + 1);
        
        close(pipefd[1]);
        wait(NULL); // Ждем завершения дочернего процесса
    }
    
    return 0;
}